(cl:in-package :cl-metaheuristics)

(deftype positive-fixnum nil '(integer 1 #.most-positive-fixnum))
(deftype nonnegative-fixnum nil '(integer 0 #.most-positive-fixnum))

(defclass problem nil nil)
(defclass annealer (problem)
  ((tmax :initform 25000.0 :initarg :tmax :type single-float)
   (tmin :initform 2.5 :initarg :tmin :type single-float)
   (max-steps :initform 50000 :initarg :max-steps :type positive-fixnum)
   (state :initarg :state)
   (state-copier :initform #'copy-seq :initarg :state-copier :type function)
   (goal-value :initarg :goal-value :type (or null real))))

(defun slots-boundp (object slot-names)
  (or (null slot-names)
      (and (slot-boundp object (car slot-names))
           (slots-boundp object (cdr slot-names)))))

(defmethod initialize-instance :after ((annealer-obj annealer) &rest initargs)
  (declare (ignore initargs))
  (with-slots (tmax tmin max-steps state-copier goal-value) annealer-obj
    (assert (slots-boundp annealer-obj
                          '(tmax tmin max-steps state-copier goal-value)))
    (check-type tmax single-float)
    (check-type tmin single-float)
    (assert (> tmax tmin 0))
    (check-type max-steps positive-fixnum)
    (check-type state-copier function)
    (check-type goal-value (or null real))))

(defgeneric move (annealer-obj))
(defgeneric evaluate (problem-obj))
(defgeneric solve (problem-obj &key inform-per-time))

(defmethod solve ((annealer-obj annealer) &key (inform-per-time 500) (silent nil))
  "Solve a problem by simulated annealing."
  (declare (positive-fixnum inform-per-time)
           (optimize (speed 3) (safety 1)))
  (with-slots (tmax tmin max-steps state state-copier goal-value) annealer-obj
    (declare (single-float tmax tmin)
             (positive-fixnum max-steps)
             (function state-copier)
             ((or null real) goal-value))
    (let* ((value (evaluate annealer-obj))
           (best-state (funcall state-copier state))
           (best-value value)
           (/max-steps (/ 1.0 max-steps))
           (/max-steps100 (* /max-steps 100))
           (factor (* (log (/ tmin tmax)) /max-steps)))
      (declare (single-float factor /max-steps))
      (labels ((temperature (i)
                 (declare (nonnegative-fixnum i))
                 (* tmax (exp (* factor i))))
               (probability (e1 e2 temp)
                 (declare (real e1 e2)
                          (single-float temp))
                 (exp (/ (- e1 e2) temp))))
        (declare (inline temperature probability))
        (macrolet
            ((body (goal-exists)
               `(iter (for i below max-steps)
                      (for i-mod from 0)
                      (when (and (= i-mod inform-per-time)
                                 (not silent))
                        (format t "Progress: ~,2F%, Value: ~,2F, Best value: ~,2F~%"
                                (* i /max-steps100)
                                value
                                best-value)
                        (setf i-mod 0))
                      (let ((prev-state (funcall state-copier state))
                            (prev-value value))
                        (move annealer-obj)
                        (let ((next-state state)
                              (next-value (evaluate annealer-obj)))
                          (when (< next-value best-value)
                            (progn (setf best-state (funcall state-copier next-state)
                                         best-value next-value)
                                   ,(if goal-exists
                                        `(when (<= best-value goal-value)
                                           (finish))
                                        nil)))
                          (if (or (<= next-value prev-value)
                                  (<= (random 1d0)
                                      (probability prev-value next-value (temperature i))))
                              (setf value next-value
                                    state prev-state)))
                        (finally (return (values best-state
                                                 best-value)))))))
          (if goal-value
              (body t)
              (body nil)))))))
